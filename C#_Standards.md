# Development Standards and Guidelines (C#)
## [Contents](https://github.com/CA-CST-SII/SoftwareStandards/blob/master/C%23_Standards.md#contents)

[1	About the Guide](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#1--about-the-guide)

[2	Purpose](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#2--purpose)

[3	Library Organization](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#3-library-organization)

&nbsp;&nbsp;[3.1	Library Taxonomy](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#31-library-taxonomy)

&nbsp;&nbsp;[3.2	Library Structure](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#32-library-structure)

&nbsp;&nbsp;[3.3	Library Usage](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#33-library-usage)

[4	Programming Standards](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#4-programming-standards)

&nbsp;&nbsp;[4.1	About Code Uniformity](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#41-about-code-uniformity)

&nbsp;&nbsp;[4.2	Naming Conventions](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#42-naming-conventions)

&nbsp;&nbsp;&nbsp;&nbsp;[4.2.1 Naming Overview](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#421-naming-overview)

&nbsp;&nbsp;&nbsp;&nbsp;[4.2.2 Hungarian Notation] (https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#422-hungarian-notation)

&nbsp;&nbsp;&nbsp;&nbsp;[4.2.3 Capitalization Styles](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#423-capitalization-styles)

&nbsp;&nbsp;&nbsp;&nbsp;[4.2.4 Naming Guidelines](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#424-naming-guidelines)

&nbsp;&nbsp;[4.3	Code Structure](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#43-code-structure)

&nbsp;&nbsp;&nbsp;&nbsp;[4.3.1 Code Separation](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#431-code-separation)

&nbsp;&nbsp;&nbsp;&nbsp;[4.3.2 Wrapping Lines](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#432-wrapping-lines)

&nbsp;&nbsp;&nbsp;&nbsp;[4.3.3 Declarations](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#433-declarations)

&nbsp;&nbsp;&nbsp;&nbsp;[4.3.4 Formatting Conditional/Flow Statements](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#434-formatting-conditionalflow-statements)

&nbsp;&nbsp;&nbsp;&nbsp;[4.3.5 Implementing Structure Standards](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#435-implementing-structure-standards)

[5	Best Practices](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#5-best-practices)

&nbsp;&nbsp;[5.1 Visibility](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#51-visibility)

&nbsp;&nbsp;[5.2 No embedded, user-facing strings](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#52-no-embedded-user-facing-strings)

&nbsp;&nbsp;[5.3 No 'magic' Numbers](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#53-no-magic-numbers)


[6. Code Level Metrics](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#6-code-level-metrics)

[7. Simple Coding Guidelines](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#7-simple-coding-guidelines)

[8	Code Examples](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#8-code-examples)

&nbsp;&nbsp;[8.1	Brace Placement Example](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#81-brace-placement-example)

&nbsp;&nbsp;[8.2	Variable Naming Example](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#82-variable-naming-example)

[9	Embedded Comments and Documentation](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#9-embedded-comments-and-documentation)

&nbsp;&nbsp;[9.1	Avoid Methods with a Very Low Comments/Code Ratio](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#91--avoid-methods-with-a-very-low-commentscode-ratio)

&nbsp;&nbsp;[9.2	Avoid Classes with a Very Low Comment/Code Ratio](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#92--avoid-classes-with-a-very-low-commentcode-ratio)

&nbsp;&nbsp;[9.3	Avoid Interfaces with a Very Low Comment/Code Ratio](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#93--avoid-interfaces-with-a-very-low-commentcode-ratio)

&nbsp;&nbsp;[9.4	Block Comments](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#94-block-comments)

&nbsp;&nbsp;[9.5	Single-Line Comments](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#95-single-line-comments)

&nbsp;&nbsp;[9.6	XML Documentation Overview](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#96-xml-documentation-overview)

&nbsp;&nbsp;&nbsp;&nbsp;[9.6.1 XML Documentation Tag Usage](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#961-xml-documentation-tag-usage)

&nbsp;&nbsp;&nbsp;&nbsp;[9.6.2 Implementing XML Documentation](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#962-implementing-xml-documentation)

[Appendix A - XML Documentation Tags](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#appendix-a---xml-documentation-tags)

## [Tables](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#tables)
[Table 6. Code Level Metrics](#Table 6)

## 1.  About the Guide
This guide covers structuring and naming of the Vantage libraries in such a manner that other developers/teams can easily determine whether or not an object that provides desired functionality already exists, easily locate objects slated for modification, and decide where to include new development.  The guide also covers software coding standards; and although the primary focus will be on programs written in C #, many of the rules and principles are useful and apply to programs written in other languages.  Finally, the guide will briefly cover embedded XML documentation and includes a more extensive elaboration on usage in [Appendix A] (https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#appendix-a---xml-documentation-tags) - taken from a white paper article written by Anson Horton from the .NET Framework community website. 

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

## 2.  Purpose
Project specific C# coding standards are maintained by the lead developer for each project.

It is expected that all new C# code will adhere to these standards; existing code can be retrofitted to meet the standards to whatever degree possible, as modifications to that code are required. 

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

## 3. Library Organization
### 3.1 Library Taxonomy
The taxonomy presented in this section is a partial library layout with some explanation.  

Structure and usage will be discussed in the subsequent sections.  
* Vantage.Services
  * Common – Houses the company’s core objects that are not “Account” specific (e.g., the Data Access Layer) and may be shared across multiple projects/accounts.
    * DataAccess
      * DBConnection.cs
      * DBConnectionFactory.cs
      * …
    * Hardware
      * Factory
        * …
    * Helper
      * NumericString.cs
      * XMLHelper.cs
      * ParameterizedString.cs
      * TokenValue.cs
      * …
    * MoneyManagement
      * MoneyManager.cs
    * SecurityManagement
      * SecurityManager.cs
    * UI
      * Web
        * … 
      * Windows
        * DesignSuite
    * Utils
      * Settings
  * Passport – Houses account specific common objects	
    * FEPClient
  * PATS
    * …
  * PIERS
    * …
  * PRISM
    * …
  * TDIS
    * Common – Houses project specific common objects
      * DataAdapter
      * DataFormatter
      * Passport
      * Project specific business entity objects.
      * PassportManagement
      * Project specific business entity management objects.
    * Support
      * SecurityManagement
      * SettingsManagement
    * Workflow
      * Adjudication
      * SignatureService
      * QualityControl

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

### 3.2 Library Structure
The library directory should be structured and named in a manner that makes it intuitive for a developer to easily check for existing functionality.  In general namespaces should match with the corresponding code directory structure (e.g., Vantage.Services.Estimator.Models would align with the Vantage.Services/Estimator/Models path).  This makes it easier to map namespaces to the directory layout, and makes it a relatively trivial matter for a developer to look for the appropriate “using” directive in a code file and locate the underlying functionality.  

However, this is not to say that every folder MUST map to a namespace.  If you’re creating a sub-folder within a project for organizational purposes, it is recommended that the objects within these folders share the same root namespace as the project (e.g., items within the Vantage/Services/Estimator/Models/Order folder would lie within the Vantage.Services.Estimator.Models namespace).  Again, this greatly simplifies library inclusion with the “using” directive and may vastly reduce the impact of a library consolidation and re-organization.

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

### 3.3 Library Usage
The first place a Team/Developer should look for developing a NEW system or Project is in the Apptis.Common section of the library.  If there is no existing functionality for the GENERAL type of development they are performing and it is conceivable that other systems may need the functionality at some future point, it should be implemented within the Apptis.Common section for other Projects to use.  Likewise, this may also be a good time to investigate whether other Developers/Teams have implemented functionality similar to what is needed, and if so, considering abstracting it out into the Apptis.Common section of the library.  

When adding/extending functionality to an existing Project, a developer should be able to look in the module folder (i.e., look in Apptis.TDIS.ModuleName if modifying an existing module) to see how current functionality has been implemented, and look to the Project and Apptis Common folders for existing business or non-domain specific objects.  If the folder structure is laid out in a sensible fashion and the underlying objects carry with them meaningful names, it should be relatively easy to determine whether or not there are existing pieces to the puzzle they are working on.  Again this is also a good time to look for existing functionality that is not in the Common area and re-factor and move it out if possible.  

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

## 4. Programming Standards
### 4.1 About Code Uniformity
Whereas most developers are familiar with writing code that a compiler can interpret, this section may be read as a guide that focuses on helping developers adopt code Naming Conventions, Structure, and Documentation/Comments that will help other developers understand the purpose of existing code.  Typically it is much simpler for a developer to familiarize their self with new code that has naming conventions and formatting similar to their own.  

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

### 4.2 Naming Conventions
#### 4.2.1 Naming Overview
In general, put every class in a separate file and name the file like the class name.  An exception to this would be private inner classes.  Class names typically describe the business entity that the class represents or the function or set of functionality the class provides.  This convention makes things much easier to follow and significantly lends to self-documenting code.  Class and file names should NOT include the company and/or project name (e.g. CPQSecurity, VantageUser, etc.).  Although this may have made some small amount of sense for COM objects, the combination of appropriate module name selection and the namespace paradigm used throughout the .NET framework make this unnecessary.   An obvious exception to this would be Bridge or Adapter classes where the name denotes the systems being bridged (e.g., TDISFEPAdapter).

For classes/files/methods keep your source code short, divide your code up into methods that are named such that their purpose is clear.  Unusually long classes/methods are sometimes cumbersome to name (not to mention read through) as they often perform multiple semi-atomic tasks.  This usually a good sign that some method and/or class refactoring is in order.

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

#### 4.2.2 Hungarian Notation
Generally, the use of Hungarian notation in the naming objects/variables is considered poor practices in terms of modern programming standards.  

Hungarian notation is a defined set of prefixes and suffixes, which are applied to names to reflect the type of the variable.  This style of naming was widely used in early Windows programming, but now is obsolete or at least should be considered deprecated.  Using Hungarian notation is not allowed if you follow this guide.

Instead modern standards call for names that denote usage rather than type.  In other words a good variable name describes the semantic. 

One exception to this rule is UI code. All fields and variable names that contain UI elements such as a button should be prefixed with their abbreviated type name. For example:

```C#
System.Windows.Forms.Button btnCancel;
System.Windows.Forms.TextBox txtFirstName;
```

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

#### 4.2.3 Capitalization Styles

##### 4.2.3.1 *Camel Casing*
This convention capitalizes the first character of each word except the first one (e.g.<code>standardsAndGuidelines</code>).  Other conditions are as follow:

*	The first letter is capitalized. 
*	One or more letters in that word are also capitalised. 
*	The word does not end on a capitalized letter: CamelCasE 
*	No two capitalised letters shall follow directly each other: CamelCAse 
*	No number in that word at any place: CamelCase1more 
*	No dot(.), under_score or dash (-) within the word, only letters: Camel_Case


##### 4.2.3.2 *Pascal Casing*
This convention capitalizes the first character of each word (e.g., <code>StandardsAndGuidelines</code>).

##### 4.2.3.3 *Upper case*
Only use all upper case for identifiers if it consists of an abbreviation or acronym that is only a few characters long.  Longer identifiers should use Pascal Casing instead.

For Example:
```C#
public class Math
{
    public const PI # ...
    public const E # ...
    public const FeigenBaumNumber # ...
}
```

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

#### 4.2.4 Naming Guidelines
##### 4.2.4.1 *Class Naming Guidelines*
* Class names must be nouns or noun phrases.
* Use Pascal Casing.
* Do not use any class prefix.

##### 4.2.4.2 *Interface Naming Guidelines* 
* Name interfaces with nouns or noun phrases or adjectives describing behavior. (Example IComponent or IEnumberable)
* Use Pascal Casing.
* Use I as prefix for the name, it is followed by a capital letter (first char of the interface name)

##### 4.2.4.3 *Enum Naming Guidelines* 
* Use Pascal Casing for enum value names and enum type names.
* Don’t prefix (or suffix) an enum type or enum values.
* Use singular names for enums.

##### 4.2.4.4 *Static and Const Field Names* 
* Name static fields with nouns, noun phrases or abbreviations for nouns
* Use Pascal Casing.

##### 4.2.4.5 *Non- const Field /Member Variable Names* 
* Use descriptive names that, if done properly should be enough to indicate the variable meaning/usage and provide insight into the underlying type.
* Use an underscore “_” as a prefix for private and protected class member variables (declared at the top of the class above any constructors) so they can be easily identified and located.
*Use Camel Casing after the underscore.

##### 4.2.4.6 *Method Names*
* Name methods with verbs or verb phrases.
* Use Pascal Casing.

##### 4.2.4.7 *Method Parameters and Local Variables*
* Use descriptive names that, if done properly should be enough to indicate the variable meaning/usage and provide insight into the underlying type.
* Use Camel Casing.

##### 4.2.4.8 *Property Names*
* Name properties using nouns or noun phrases.
* Use Pascal Casing.
* Consider naming a property with the same name as the underlying class variable (without the underscore prefix).

##### 4.2.4.9 *Event Names*
* Name event handlers with the EventHandler suffix.
* Use two parameters named sender and e.
* Use Pascal Casing.
* Name event argument classes with the EventArgs suffix.
* Name event names that have a concept of pre and post using the present and past tense.
* Consider naming events using a verb.  
* Consider using the “On” prefix, e.g., OnStart.

##### 4.2.4.10	*Namespace Names*
*	Use Pascal Casing.

##### 4.2.4.11	*Private/Public Fields Names*
*	Use Pascal Casing.
*	Do not include any underscore.
	
##### 4.2.4.12	*Controls Names*
*	Use naming conventions (Exmaple btn* for buttons, chk* for check boxes, cmb* for combo boxes)
*	Do not include any underscore.

##### 4.2.4.13	*Exception Names*
*	Use Pascal Casing.
*	End with X.

##### 4.2.4.10 *Capitalization summary*

<table>
<caption>style#“caption-side:bottom;”|<em>Table 4.2.4.10 Capitalization Summary</em></caption>
<thead>
<tr class="header">
<th align="left"><p>Type</p></th>
<th align="left"><p>Case</p></th>
<th align="left"><p>Notes</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><p>Class/Struct</p></td>
<td align="left"><p>Pascal Casing</p></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><p>Interface</p></td>
<td align="left"><p>Pascal Casing</p></td>
<td align="left"><p>Start with I</p></td>
</tr>
<tr class="odd">
<td align="left"><p>Enum values</p></td>
<td align="left"><p>Pascal Casing</p></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><p>Enum type</p></td>
<td align="left"><p>Pascal Casing</p></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><p>Events</p></td>
<td align="left"><p>Pascal Casing</p></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><p>Exception class</p></td>
<td align="left"><p>Pascal Casing</p></td>
<td align="left"><p>End with Exception</p></td>
</tr>
<tr class="odd">
<td align="left"><p>Public Fields</p></td>
<td align="left"><p>Pascal Casing</p></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><p>Methods</p></td>
<td align="left"><p>Pascal Casing</p></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><p>Namespace</p></td>
<td align="left"><p>Pascal Casing</p></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><p>Property</p></td>
<td align="left"><p>Pascal Casing</p></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><p>Protected/Private Fields</p></td>
<td align="left"><p>Camel Casing</p></td>
<td align="left"><p>Start with “_” for class level</p></td>
</tr>
<tr class="even">
<td align="left"><p>Parameters/Local Variables</p></td>
<td align="left"><p>Camel Casing</p></td>
<td align="left"></td>
</tr>
</tbody>
</table>

### 4.3 Code Structure
#### 4.3.1 Code Separation
##### 4.3.1.1 *Separation Overview*
Imagine trying to read a book or a magazine article with no spaces between the words or any 
indentation and/or blank lines to set-off or separate paragraphs.  It becomes readily 
apparent just how powerful these simple formatting tools are in contributing to the flow and 
readability of the text.  Similarly, the proper usage of indentation, blank lines, and white 
spaces will vastly improve the flow and readability of source code. 

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

##### 4.3.1.2 *Indentation*
An indentation standard using spaces never was achieved.  Some people like 2 spaces; some 
prefer 4 and others 8, or even more spaces.  For this reason it is better use tabs and we 
define the Tab as the standard indentation character.  Tab characters have some advantages:

* Everyone can set their own preferred indentation level
* It is only 1 keystroke and not 2, 4, or 8…and will therefore reduce typing (even with “smart 
indenting” you have to set the indentation manually sometimes, or take it back or whatever).
* If you want to increase the indentation (or decrease), mark one block and increase the 
indent level with Tab with Shift-Tab you decrease the indentation. This is true for almost 
any text editor.

Indentation should be used in the following manner:

* Subordinate scopes/clauses should be indented one level in from the next higher scope (see 
Code Examples).
  * The class, interface, struct, enum, and delegate declarations should be one level in from 
the namespace declaration.
  * Constructors, Fields, Properties, Methods, etc. should be one level in from the class 
declaration.
  * Source code within Constructors, Properties, Methods, etc. should be indented one level.
  * Subordinate statements within conditional and flow statements should be indented one level 
(see Formatting Conditional/Flow Statements).
* If a declaration or statement continues onto subsequent lines the “wrapped” portion should 
be indented (see Wrapping Lines).

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

##### 4.3.1.3 *Blank Lines*
Blank lines used within and between Methods, Properties, etc. improve readability.  They set 
off blocks of code that are logically related.

Two blank lines should always be used between:

* Logical sections of a source file (e.g., between code regions).
* Class and interface definitions (use one class/interface per file to prevent this case).

One blank line should always be used between:

* Methods
* Properties
* Local variables in a method and its first statement
* Logical sections inside a method to improve readability

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

##### 4.3.1.4 *Spacing*
The following spacing rules should be followed:
* No space between a method name and the opening parenthesis "(".
* No space between the parentheses for methods with no params in the signature.
* All items in a Class declaration should be separated by spaces (see Class, Interface, and 

Method Declarations).
* All parameters/expressions within parentheses should be separated by spaces located after 

the opening parenthesis, after the commas or semicolons, and before the closing parenthesis.
* Nested parentheses should be separated by spaces from the outer parentheses as well as the 
contained expression.
*No spaces should be used within parentheses that denote an explicit object cast.
*Surround operators with single spaces (except unary operators like increment or logical 
not).

Method example:

Use:
```C#
TestMethod();
```
Or
```C#
TestMethod( paramName1, paramName2, paramName3 );
```

Don't use: 
```C#
TestMethod(paramName1,paramName2,paramName3);
```
Or
```C#
TestMethod(paramName1, paramName2, paramName3);
```

Flow example:

Use:
```C#
for( int loopIndex # 0; loopIndex < 10; loopIndex++ )
```

Don't use:
```C#
for(int loopIndex#0; loopIndex<10; loopIndex++)
```
Or
```C#
for(int loopIndex#0;loopIndex<10;loopIndex++)
```

Nested parentheses example:

Use:
```C#
if( ( ( printStatus & PrintError ) !# PrintError ) ||
    ( ( printStatus & PrintBypass ) ## PrintBypass ) )
{
	…
}
```

Don’t use:
```C#
if( ( (printStatus & PrintError) !# PrintError ) ||
    ( (printStatus & PrintBypass) ## PrintBypass ) )
{
	…
}
```
	Or
```C#
if( ((printStatus & PrintError) !# PrintError) ||
    ((printStatus & PrintBypass) ## PrintBypass) )
{
	…
}
```

Explicit cast example:
```C#
double someDouble # 1234.7;
int someInt;
```
Use:
```C#
someInt # (int) someDouble;
```
Or
```C#
someInt # (int)someDouble;
```

Don't use:
```C#
someInt # ( int )someDouble;
```

Operator example:

Use:
```C#
prevVariable # curVariable;
```

Don't use:
```C#
prevVariable#curVariable;
```

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

#### 4.3.2 Wrapping Lines
When an expression will not fit on a single line, break it up according to these general 
principles:

* Break after a comma.
* Break after an operator.
* Prefer higher-level breaks to lower-level breaks.

Example of breaking up method calls:
```C#
MethodCall( variableName1, variableName2, variableName3,
	variableName4, variableName5 );
```
Or
```C#
MethodCall( variableName1, variableName2, variableName3,
            variableName4, variableName5 );
```

Examples of breaking an arithmetic expression:

Use:
```C#
someResult # a * b / ( c - g + f ) + 
4 * z;
```
Or
```C#
someResult # a * b / ( c - g + f ) + 
      4 * z;
```

Don’t use:
```C#
someResult # a * b / ( c - g +
f ) + 4 * z;
```
The first is preferred since the break occurs outside the parenthesized expression (i.e., 
flows and reads better with the order of operations in mind).  


NOTE: If you prefer to use indentation that lines variables and/or the right hand portion of 
expressions up with those on the previous line, then you MUST use tabs only to where the 
previous line began and spaces for the rest of the indentation.  Otherwise, formatting will 
be disrupted for developers using tab lengths that differ from your own.  

Examples of using tab/char combinations to preserve alignment:
```C#
>MethodCall( variableName1, variableName2, variableName3,
>............variableName4, variableName5, variableName6 );

>var # a * b / ( c - g + f ) +
>......4 * z;
```
Where `'>'` are tab chars and `'.'` are spaces (the spaces after the tab char must begin under 
the first char of the previous line).  For this reason it may be easier to simply indent with 
an additional tab rather than align continuations of variable lists and expressions.

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

#### 4.3.3 Declarations
##### 4.3.3.1  *Number of Declarations per Line*
One declaration per line is recommended since it allows for commenting should the variable 
name not suffice.  In other words,

```C#
int floorNumber; 	
int totalFloors; // The total number of floors in the building
```

Do not put more than one variable on a line unless their usage is closely related.  Do not 
put variables of different types on the same line when declaring them.  Example:

```C#
int a, b; // What is 'a'? What does 'b' stand for?
```
The above example also demonstrates the drawbacks of non-obvious variable names.  

##### 4.3.3.2	*Avoid declaring public Fields*
Public Fields (defined in a class) should not be used.  Public Fields can be accessed by any other Class, Therefore its value can be modified at any time, without control by the Class itself. In addition, direct use of Public Fields does not let Field definition evolve without requiring updates to all Objects referencing it.  This goes against OO Encapsulation concepts.

##### 4.3.3.3 *Initialization*
Wherever possible try to initialize local variables as soon as they are declared. 

For example:
```C#
string mLastName # string.Empty;
```
Or
```C#
string lastName # curEmployee.LastName;
```
Or
```C#
double hoursWorked # timePeriod.Hours;
```

Note: If you initialize a dialog try to use the using statement:
```C#
using( OpenFileDialog openFileDialog # new OpenFileDialog() )
{
...
}
```

##### 4.3.3.4 *Class, Interface, and Method Declarations*
* The opening brace "{" appears in the next line after the declaration statement.
* The closing brace "}" starts a line by itself indented to match its corresponding opening 
brace.

For example:
```C#
class BoundedCounter : CounterBase, ICounter
 {
  int _upperBound;
  int _lowerBound;
  int _countStart;
		
 public MySample( int countStart, int upperBound, 
  int lowerBound )
 {
  _countStart # countStart;
  _upperBound # upperBound;
  _lowerBound # lowerBound;
 }

 void Increment()
 {
	if( _countStart < upperBound )
	{
          CounterBase.Increment();
	}
 }

 void Decrement()
 {
	if( _countStart > lowerBound )
	{
          // Call the base class decrement
			}
        }

 void EmptyMethod()
 {
	// How’d I end up here?
 }
}
```
For a brace placement example see the Brace Example.

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

#### 4.3.4 Formatting Conditional/Flow Statements
##### 4.3.4.1 *Formatting if, if-else, if else-if else Statements*
The if, if-else and else-if else statements should be formatted as follows:
```C#
if( condition )
{
 DoSomething();
 ...
}

if( condition )
{
 DoSomething();
 ...
}
else
{
 DoSomethingOther();
 ...
}

if( condition )
{
 DoSomething();
 ...
}
else if( condition )
{
 DoSomethingOther();
 ...
}
else
{
 DoSomethingOtherAgain();
 ...
}
```
Note: Generally use brackets even if there is only one statement in condition.

##### 4.3.4.2 *Formatting for / foreach Statements*
A for statement should have following format:
```C#
for( int loopIndex # 0; loopIndex < 5; ++ loopIndex )
{
 ...
}
```
Or single lined (consider using a while statement instead):
```C#
for( [initialization expression]; [loop condition]; 
[update expression] );
```
A foreach should look like:
```C#
foreach( int i in IntList )
{
 ...
}
```
Note: Generally use brackets even if there is only one statement in the loop.

##### 4.3.4.3 *Formatting  while/do-while Statements*
A while statement should be written as follows:
```C#
while( condition )
{
 ...
}
```
Note: Generally use brackets even if there is only one statement in the loop.

An empty while should have the following form:
```C#
while( condition );
```
A do-while statement should have the following form:
```C#
do
{
 ...
} 
while( condition );
```

##### 4.3.4.4 *Formatting switch Statements*
A switch statement should be of following form:
```C#
switch( condition )
{
 case A:
  ...
  break;
 case B:
  ...
  break;
 default:
  ...
  break;
}
```

##### 4.3.4.5 *try-catch Statements*
A try-catch statement should follow this form:
```C#
try
{
 ...
}
catch( Exception ) 
{
  // We don't care if it fails because we're shutting down anyway.
}
```
NOTE:  If you plan on catching and ignoring the error, a good practice is to place a comment 
in the catch block explaining why.

Or
```C#
try
{
 ...
}
catch( Exception e )
{
 ...
}
```
Or 
```C#
try
{
 ...
}
catch( Exception e )
{
 ...
}
finally
{
...
}
```

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

#### 4.3.5 Implementing Structure Standards
##### 4.3.5.1 *Within Visual Studio*
For the most part In Visual Studio 2003 these code formatting practices must be adopted and 
adhered to via the developer’s own diligence.

In Visual Studio 2005 the structure rules described above, along with additional layout and 
formatting rules, must be configured by using the C# Code Options depicted in the screen 
shots below.


TODO:  Screen Shots to be added.


## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

## 5. Best Practices
### 5.1 Visibility
Do not make any instance or class variable public make them private or protected.   Instead, 
use properties if you need to expose a class variable.  You may use public static fields (or 
const) as an exception to this rule, but it should not be the rule.

### 5.2 No embedded, user-facing strings.
No UI elements (Labels, Drop Downs, Text Boxes, Error Messages, etc.) should use text that is 
embedded in the application.  In .Net much of this can be overcome by enabling localization, 
and the remainder should rely on some construct that can display the appropriate text from a 
persistent store such as the Notification layer.

### 5.3 No 'magic' Numbers
Don’t use magic numbers, i.e. place constant numerical values directly into the source code. 
Replacing these later on in case of changes (say, your application can now handle 32767 users 
instead of the 255 hard-coded into your code in 50 lines scattered throughout your 25000 LOC) 
is error-prone, not productive, and an all around bad programming practice.  Instead declare 
a const variable which contains the number:
```C#
public class MyMath
{
  public const double PI # 3.14159...
}
```

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

## 6. Code Level Metrics
Code level metrics (both at method and class levels) serve to keep the characteristics of the code within certain limits in order to enhance the readability/understandability, maintainability, testability, and in certain cases, security and performance of the code.  The most commonly known metric is the Cyclomatic complexity or very roughly, the number of decision-making and/or branches in the code. High levels of complexity lead to difficulty understanding and testing code and therefore reduce the maintainability and testability of the code. The less complexity in the C# code, the less room for error, the easier it is to test and to understand and therefore maintain the code. Ensure your C# code meets the following metrics:
<a name="Table 6"></a>
<table>
<caption><em>Table 6 Code level metrics</em></caption>
<thead>
<tr class="header">
<th align="left"><p>Class Level</p></th>
<th align="left"><p>Description and How to Calculate</p></th>
<th align="left"><p>Recommended Threshold</p></th>
</tr>
</thead>
<tbody>
<tr class="even">
<td align="left"><p>Classes with High number of Methods</p></td>
<td align="left"><p>Such classes are difficult to understand, maintain and test.  Count the number of methods per class and keep them below the recommended threshold. </p></td>
<td align="left"><p>Less than 30</p></td>
</tr>
<tr class="odd">
<td align="left"><p>Classes with High # of Constructors</p></td>
<td align="left"><p>Count the number of constructors per class and keep them below the recommended threshold.</p></td>
<td align="left"><p>Less than 5</p></td>
</tr>
<tr class="even">
<td align="left"><p>Classes with High # of Fields</p></td>
<td align="left"><p>Count the number of fields per class and keep them below the recommended threshold.</p></td>
<td align="left"><p>Less than 20</p></td>
</tr>
<tr class="odd">
<td align="left"><p>Class Implementing Too Many Interfaces</p></td>
<td align="left"><p>Avoid classes implementing more than the recommended threshold </p></td>
<td align="left"><p>Less than 5</p></td>
</tr>
<tr class="even">
<td align="left"><p>Classes with High Coupling Between Objects</p></td>
<td align="left"><p>The Coupling Between Object (CBO) is equal to the fan-out of a class, that is, the number of other classes that are referenced through one of its methods or one of its fields. Excessive coupling between objects is detrimental to modular design and prevents reuse. The larger the number of couples, the higher the sensitivity to changes in other parts of the design and therefore the more difficult the maintenance. High CBO numbers might indicate that a class has too many responsibilities. Such a class is potential candidate for a refactoring where the class would delegate some the responsibilities to other classes or new classes (extract class, extract method refactoring). This will increase modularity and reusability. When refactoring with architecture in mind, the CBO metric can be used to check classes running on the application client that have high coupling. These classes are then good candidate for a refactoring towards the session facade pattern.</p></td>
<td align="left"><p>Less than 3</p></td>
</tr>
<tr class="odd">
<td align="left"><p>Classes with High Response</p></td>
<td align="left"><p>High Response for a Class (RFC) is the total number of local methods and remote methods called by methods in the class. If a large number of methods can be invoked in response to a message, the testing and debugging of the class becomes more complicated since it requires a greater level of understanding required on the part of the tester. Reduce the number of local methods and remote methods called by methods in the class..
 </p></td>
<td align="left"><p>Less than 50</p></td>
</tr>
<tr class="even">
<td align="left"><p>Classes with High Weighted Methods per Class</p></td>
<td align="left"><p>The weighted methods per class metric is defined as the sum of all the class method's cyclomatic complexity. The number of methods and complexity of methods is an indicator of how much time and effort is required to develop and maintain the object. For maintainability reasons, high weighted methods per class should not be too high. Reduce the number - by splitting the class in two or moving method to a component class - or the cyclomatic complexity of the method of the non-compliant class.</p></td>
<td align="left"><p>Less than 100</p></td>
</tr>
<tr class="odd">
<td align="left"><p>Classes with a High Depth of Inheritance Tree</p></td>
<td align="left"><p>The inheritance tree should have at most X levels. Depth of Inheritance Tree (DIT) is the maximum length of a path from a class to a root class in the inheritance structure of a system. DIT measures how many super-classes can affect a class. Changing a class requires prior understanding, which, in turn, is more complicated for classes with many methods. Classes that are deep down in the class hierarchy potentially inherit many methods from super-classes. Moreover, the definitions of inherited methods are not local to the class making it even harder to understand it. Complete testing requires coverage of all execution paths. The number of possible execution paths of a class increases with the number of methods and their control flow complexity. Due to late binding, super-class methods need to be tested again in the subclass context. This makes it potentially harder to test classes deep down in the class hierarchy.</p></td>
<td align="left"><p>Less than 10</p></td>
</tr>
<tr class="odd">
<td align="left"><p>Classes with a High Public Data Ratio</p></td>
<td align="left"><p>Public data ratio is the percentage of public fields among all fields. Properties are not considered as fields. Public fields are accessible by any other class, therefore their values can be modified at any time, without control by the class itself. This goes against OO encapsulation concepts. It is necessary to change the field visibility to private.</p></td>
<td align="left"><p>Less than 85%</p></td>
</tr>
<tr class="even">
<td align="left"><p>Classes Dependent on their Children </p></td>
<td align="left"><p>Do not create class structures that have circular dependencies or parents that make calls to child methods. This is a violation of OO programming guidelines as no parent class shall be dependent on its children.</p></td>
<td align="left"><p>ZERO</p></td>
</tr>
<tr class="odd">
<td align="left"><p>Classes with a High Number Of Children</p></td>
<td align="left"><p>High Number Of Children (NOC) is the number of immediate sub classes of the Class. Depth is generally better than breadth in class hierarchy, since it promotes reuse of methods through inheritance. NOC measures the potential influence a class has on the design. Classes with large number of children require more intensive testing as through inheritance an implementation error can potentially lead to many regression bugs. Technical or framework classes which are evolving and will not be changed often should not be concerned by this rule.</p></td>
<td align="left"><p>Less than 4</p></td>
</tr>
<tr class="even">
<td align="left"><p>Highly Coupled Classes</p></td>
<td align="left"><p>Count of number of references to classes outside the current class hierarchy and stay within the recommended threshold.  Highly coupled classes violate encapsulation and modularity guidelines and reduce potential re-use and component development capabilities since they are coupled with multiple other structures.</p></td>
<td align="left"><p>Less than or equal to 2 </p></td>
</tr>
<tr class="odd">
<td align="left"><p>Classes with a High Lack of Cohesion</p></td>
<td align="left"><p>Lack of cohesion implies classes should probably be split into two or more sub/classes. Cohesiveness of methods within a class is desirable, since it promotes encapsulation. Low cohesion increases complexity, thereby increasing the likelihood of errors during the development process. Avoid classes with a high lack of cohesion in methods.</p></td>
<td align="left"><p>Less than 95%</p></td>
</tr>
<thead>
<tr class="header">
<th align="left"><p>Method Level</p></th>
<th align="left"><p>Description and How to Calculate</p></th>
<th align="left"><p>Recommended Threshold</p></th>
</tr>
</thead>
<tr class="odd">
<td align="left"><p>Cyclomatic Complexity </p></td>
<td align="left"><p>Cyclomatic complexity is a measure of the complexity of the control structure of an artifact. It is the number of linearly independent paths and therefore, the minimum number of independent paths when executing the software. It can make a piece of code harder to understand, maintain and test. In addition high levels of cyclomatic complexity can introduce security risks as hard-to-understand code may perform undesirable actions. The effort and time for diagnosis of deficiencies or causes of failures, or for identification of parts to be modified is directly related to the number of execution paths, i.e., the complexity of the control flow. Analyzability declines with increasing cyclomatic complexity.  Cyclomatic complexity computes the number of the linearly independent paths, a lower bound of all execution paths ignoring multiple iterations. Changeability declines with increasing cyclomatic complexity. Complete testing requires coverage of all execution paths. Review the design of the artifact to reduce number of independent paths, i.e., reduce the number of conditional statements.</p></td>
<td align="left"><p>Less than or equal to 20</p></td>
</tr>
<tr class="even">
<td align="left"><p>Methods with Too Many Lines of Code</p></td>
<td align="left"><p></p>Large methods are more difficult to understand, and are a sign of a bad modularity of the code.</td>
<td align="left"><p>Less than 50</p></td>
</tr>
<tr class="odd">
<td align="left"><p>Design Complexity </p></td>
<td align="left"><p></p>The number of all decisions and loops that contain calls to subordinate modules. This complexity measure evaluates the dependence of a method on other methods and as such is a measure of how encapsulation and modularity (independence) guidelines have been followed.</td>
<td align="left"><p>Less than or equal to 7</p></td>
</tr>
<tr class="even">
<td align="left"><p>Avoid Large Number of String Concatenation </p></td>
<td align="left"><p>String concatenation resolved at runtime is much slower than using the StringBuilder class. Use the StringBuilder class and StringBuilder.Append() method instead.</p></td>
<td align="left"><p>Less than 10</p></td>
</tr>
<tr class="odd">
<td align="left"><p>High Depth of Code </p></td>
<td align="left"><p>Creates complexity that may be hard to understand, follow and maintain.  Depth of Code is measured as the maximum number of nested control statements in an artifact. An artifact that contains an IF statement which contains a WHILE loop which itself contains another IF statement will have a Depth of Code of 3 (at least).  Avoid artifacts with Depth of Code (DoC) greater than X. Complex artifacts are difficult to maintain. Keeping artifacts small and simple ensures a good readability of the code. Review the design of the artifact to reduce the depth of code.</p></td>
<td align="left"><p>Less than 5</p></td>
</tr>
<tr class="even">
<td align="left"><p>Global Data Complexity</p></td>
<td align="left"><p>The count of number of paths through global data.  This measurement shows the dependence of a module of code on the global data present in a system and as such can violate encapsulation and modularity guidelines and reduce potential re-use and component development capabilities since they provide “global” data to other classes and methods, making all such units of code dependent on one another; i.e., coupled with multiple other structures.</p></td>
<td align="left"><p>Less than or equal to 5</p></td>
</tr>
<tr class="odd">
<td align="left"><p>Avoid High Fan-out: </p></td>
<td align="left"><p>High values of this metric indicate excessive interaction between modules and a coupling between disparate structures. This violates encapsulation and modularity guidelines and reduces potential re-use and component development capabilities since they are coupled with multiple other structures.  The Fan-out of an artifact is the number of other artifacts that are referenced in it. When computing the Fan-out of an artifact, multiple accesses to the same component of an artifact are counted as one access. Reduce the number of referenced artifacts. The higher the number of referenced artifacts, the more difficult the maintenance and evolution as all updates in referenced artifacts will have to be tested and taken into account.</p></td>
<td align="left"><p>Less than or equal to 7</p></td>
</tr>
<tr class="even">
<td align="left"><p>Avoid High Fan-In </p></td>
<td align="left"><p>The Fan-in of an artifact is the number of other artifacts that are referencing it. When computing the Fan-In of an artifact, multiple accesses to it from the same artifact are counted as one access. The higher the number of reference to an artifact, the more difficult the maintenance as all referencing artifacts will have to be updated or tested. Reduce the number of references to the artifact.</p></td>
<td align="left"><p>Less than 5</p></td>
</tr>
<tr class="odd">
<td align="left"><p># of Logical Branches in a Method </p></td>
<td align="left"><p>Very similar to cyclomatic complexity, it is useful for understanding high paths are in need of testing in any piece of code. A module with a v(G) of 12 for example, has 22 branches which means the minimum number of paths to cover during testing.
<td align="left"><p>Less than or equal to 22</p></td>
</tbody>
</table>


## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

## 7. Simple Coding Guidelines

*	Avoid Artifacts with Too Many Parameters
*	Avoid Artifacts with Lines Longer than 80 characters
*	Avoid Artifacts with High Essential Complexity
*	Avoid String Concatenation in Loops
*	Avoid Instantiations Inside Loops
*	User Interface Elements Must Not Use Directly the Database
*	Avoid Namespaces with High Efferent Coupling (Ce)
*	Avoid Namespaces with High Afferent Coupling(Ca)
*	Call base.Dispose()or MyBase.Finalize()in the "finally" Block of Dispose(bool) Methods
*	Dispose() Methods Should Call GC.SuppressFinalize
*	Declare as “static” All Methods Not Using Instance Fields
*	Provide a Private Default Constructor for Utility Classes
*	Avoid Cyclical Calls and Inheritances Between Namespaces Content
*	Avoid Calling Properties That Clone Values In Loops
*	Avoid Catching an Exception of Type Exception
*	Avoid Throwing an Exception of Type Exception
*	Avoid Calls to AcceptChanges In a Loop
*	Avoid Empty “finally” Blocks
*	Avoid Empty “catch” Blocks
*	Avoid Large Interfaces - Too Many Methods
*	Avoid Using Untyped DataSets
*	Avoid Unreferenced Data Members and Methods
*	Avoid changing DataSource Member Before ValueMember/DisplayMember
*	Disable Constraints Before Merging DataSet
*	Avoid Doing Select on Datatable In Loops
*	Use BeginUpdate/EndUpdate When Adding Items.Add Method In Loops
*	Avoid Cross-site Scripting DOM Vulnerabilities(CWE-79)
*	Avoid SQL Injection Vulnerabilities
*	Avoid XPath, OS Commands, File Path Manipulation, and LDAP Injection Vulnerabilities
*	The “exception” Exception Should Never Be Thrown
*	Avoid Artifacts with High Integration Complexity
*	Avoid Interface Implementation on Structures
*	Avoid Unreferenced Interfaces/Classes
*	Avoid Using Keywords as Names
*	Avoid Using String.Empty for Empty String Tests
*	Data Access Must be based on Stored Procedure Calls
*	Avoid Direct Access to Database Tables
*	Avoid Superclass Knowing Subclass
*	Use an accessor method known a getter and a setter

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

## 8. Code Examples
### 8.1 Brace Placement Example
```C#
namespace ShowMeTheBracket
{
  public enum Test
  {
    TestMe,
    TestYou
  }

  public class TestMeClass
  {
    Test _test;

    public Test Test
    {
     get
     {
       return _test;
     }

      set
     {
       _test # value;
     }
    }

  void DoSomething()
  {
    if( _test ## Test.TestMe )
    {
      //...stuff gets done
    }
    else
    {
      //...other stuff gets done
    }
   }
 }
}
```
Brackets should begin on a new line after:
* Namespace declarations
* Class/Interface/Struct declarations
* Method declarations
* Looping statements with multiple subordinate statements.
* Conditional statements with multiple subordinate statements.

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

### 8.2 Variable Naming Example

Instead of:
```C#
for( int i # 1; i < num; i++ )
{
  meetsCriteria[i] # true;
}
			
for( int i # 2; i < num / 2; i++ )
{
  int j # i + i;
  while( j <# num )
  {
    meetsCriteria[j] # false;
    j +# i;
  }
}
	
for( int i # 0; i < num; i++ )
{
  if( meetsCriteria[i] )
  {
    Console.WriteLine( i + " meets criteria" );
  }
}
```

Try intelligent naming:
```C#
for( int primeCandidate # 1; primeCandidate < candidateLimit; 
    primeCandidate++ )
{
    _isPrime[primeCandidate] # true;
}

for( int factor # 2; factor < candidateLimit / 2; factor++ )
{
    int factorableNumber # factor + factor;

    while( factorableNumber <# candidateLimit )
    {
      _isPrime[factorableNumber] # false;
      factorableNumber +# factor;
    }
}

for( int primeCandidate # 0; primeCandidate < candidateLimit; 
    primeCandidate++ )
{
    if( _isPrime[primeCandidate] )
    {
      Console.WriteLine( primeCandidate + " is prime." );
    }
}
```
Note: Indexer variables are generally named i,j,k, etc.  But in cases like this, it may make 
sense to reconsider this rule.  In general, when the same counters or indexers are reused or 
can provide insight into the functionality, give them meaningful names.

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

## 9. Embedded Comments and Documentation

### 9.1	Avoid Methods with a Very Low Comments/Code Ratio
Add comments into method implementation to explain their goal and how they work.  Methods should have at least a ratio comment/code > 5%.

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

### 9.2	Avoid Classes with a Very Low Comment/Code Ratio
Add comments into class definition to explain their goal and how they work. Classes should have at least a ratio comment/code > 5%.

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

### 9.3	Avoid Interfaces with a Very Low Comment/Code Ratio
Interfaces must be documented. Documenting interfaces is extremely important as the interfaces define a contract that will be implemented and used by others. Interfaces should have at least a ratio comment/code > 5%.

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

### 9.4 Block Comments
Block comments should not be used above Constructors, Methods, and Properties.  Instead use 
the `///` XML comments discussed in a later section to give C # standard descriptions.  For the 
most part, appropriately named classes, methods, properties, and variables should make the 
code self-explanatory and limit in-line comments to the occasional, single-line `//` comments.  

However, complex algorithms/business rules occasionally do require more verbose in-line 
commenting.  In these cases if you wish to use block comments you should use the following 
style:
```C#
/* Line 1
 * Line 2
 * Line 3 
 */
```
Lining up the asterisks and closing the comment block on a separate line will visually set 
the comment block off from code for the (human) reader.   Comment blocks are also useful for 
“commenting out” sections of code during development `/` debugging; however, functionality 
being deprecated should not be “commented out” and left in the source files.  Instead, rely 
on the source repository to retain historical functionality.

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

### 9.5 Single-Line Comments
Single-line `//` comments should be used where subtle clarification is needed.  A rule of thumb 
is that the length of a comment should not exceed the length of the code being explained; 
and, with the exception of complex algorithms/business rules, the need for long comments is 
generally an indication of poorly named or structured source code.  Single-line comments may 
also be used to “comment out” code during development `/` debugging but, again, “commented out” 
code should not be left in the source files.

When single-line comments are used as in-line, code documentation they must be indented to 
the same level as the code they are clarifying.  When using single-line comments to "comment 
out" code, place the `//` comment marks at the beginning of the line to enhance the visibility 
of commented out code.  

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

### 9.6 XML Documentation Overview
In the .NET framework, Microsoft has introduced a documentation generation system based on 
XML comments. These comments are formally single line C# comments containing XML tags. They 
follow this pattern for single line comments:
```C#
/// <summary>
/// This class...
/// </summary>
```
Multi-line XML comments follow this pattern:
```C#
/// <exception cref#”BogusException”>
/// This exception gets thrown as soon as a
/// Bogus flag gets set.
/// </exception>
```
All lines must be preceded by three slashes to be accepted as XML comment lines.
Tags fall into two categories:

* Documentation items
* Formatting/Referencing

The first category contains tags like `<summary>`, `<param>` or `<exception>`.  These 
represent items that are the elements of a program's API, which must be documented for the 
program to be useful to other programmers.  These tags usually have attributes such as name 
or cref as demonstrated in the multi-line example above.  The compiler checks these 
attributes, so they should be valid.

The latter category governs the layout of the documentation, using tags such as `<code>`, 
`<list>` or` <para>`.

For a more complete explanation of XML comments see the Microsoft .NET framework SDK 
documentation.

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

#### 9.6.1 XML Documentation Tag Usage
For all classes, types, enums, and class members, a `<summary>` tag must be used, regardless of whether they are public, protected, or private.  This can be simply done by positioning the cursor on an empty line above the statement you wish to comment and typing ‘`///`’.  The VS .NET editor will automatically turn this into a correctly structured `<summary>` block, and will add `<param>` tags also if the statement is a method and has parameters.

The `<remarks>` tag should be used in addition to the `<summary>` tag for any code that does not allow for brief description.  This can be combined with the `<example>` tag to demonstrate usage if helpful.

Any method that includes parameters in its signature must have a `<param>` tag for each parameter that describes their purpose.  

Any method that throws an exception must have an `<exception>` tag to describe the exception that can be thrown and why it would be thrown.  The cref attribute of this tag WILL be evaluated by the compiler, so should refer to the actual Exception class that will be thrown.

Any method with a return value must have a `<remarks>` tag describing the return value.

Once XML documentation has been created, it is only truly useful if transforms are applied to make it readable.  A popular open source application called NDOC does a very good job of this.  NDOC can generate HTML or Windows based .chm help files. As of the writing of this guide NDOC is available in at the DevSystemSoftware/ndoc share.

More information on XML Documentation Tags can be found in [Appendix A] (https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#appendix-a---xml-documentation-tags).

## [Contents](https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)

#### 9.6.2 Implementing XML Documentation
##### 9.6.2.1 *Within Visual Studio*
In Visual Studio 2003 consider using the latest 2003 compatible GhostDoc Add-In (1.3.0 as of this writing).

In Visual Studio 2005 consider using the latest 2005 compatible GhostDoc Add-In (1.9.2 as of this writing).

There also exists Add-Ins for previewing your comments, such as QuickDocViewer. 

##[Contents] (https://github.com/GALMFG/SoftwareStandards/blob/master/C%23_Standards.md#contents)
  
# Appendix A - XML Documentation Tags

A list of recommended XML tags, with examples, includes:

##Tag: `<c>`
This tag provides a mechanism to indicate that a fragment of text within a description should be set a special font such as that used for a block of code. (For lines of actual code, use `<code>`) 

Syntax:
```C#
<c>text to be set like code</c>
```
Example:
```C#
/// <remarks>Class <c>Point</c> models a point in a two-d
/// plane.</remarks>
public class Point 
{
// …
}
```

##Tag: `<code>`
This tag is used to set one or more lines of source code or program output in some special font. (For small code fragments in narrative, use `<c>`.)

Syntax:
```C#
<code>source code or program output</code>
```
Example:
```C#
/// <summary>This method changes the point's location by
/// the given x- and y-offsets.
/// <example>For example:
/// <code>
///	Point p = new Point( 3, 5 );
///	p.Translate( -1, 3 );
/// </code>
/// results in <c>p</c>'s having the value (2,8).
/// </example>
/// </summary>
public void Translate( int xOr, int yOr ) 
{
X += xOr;
Y += yOr;
}	

```
Tag: `<example>`
This tag allows example code within a comment, to specify how a method or other library member may be used. Ordinarily, this would also involve use of the tag <code> as well.

Syntax:
```C#
<example>description</example>
```
Example:

See `<code>` for an example.


Tag: `<exception>`
This tag provides a way to document the exceptions a method can throw.

Syntax:
```C#
<exception cref="member">description</exception>
```
cref="member" – The name of a member. The documentation generator checks that the given member exists and translates member to the canonical element name in the documentation file. 
description – A description of the circumstances in which the exception is thrown. 

Example:
```C#
public class DataBaseOperations
{
	/// <exception cref="MasterFileFormatCorruptException"> 
	/// </exception>
	/// <exception cref="MasterFileLockedOpenException"> 
	/// </exception>
	public static void ReadRecord( int flag ) 
	{
		if( flag == 1 )
			throw new MasterFileFormatCorruptException();
		else if( flag == 2 )
			throw new MasterFileLockedOpenException();
		// …
	} 
}

```
Tag: `<list>`
This tag is used to create a list or table of items. It may contain a `<listheader>` block to define the heading row of either a table or definition list. (When defining a table, only an entry for term in the heading need be supplied.)

Each item in the list is specified with an <item> block. When creating a definition list, both term and description must be specified. However, for a table, bulleted list, or numbered list, only description need be specified.

Syntax:
```C#
<list type="bullet" | "number" | "table">
	<listheader>
		<term>term</term>
		<description>description</description>
	</listheader>
	<item>
		<term>term</term>
		<description>description</description>
	</item>
	…
	<item>
		<term>term</term>
		<description>description</description>
	</item>
</list>
```
term - The term to define.
description  - The definition of the term.

Either an item in a bullet or numbered list, or the definition of a term. 

Example:
```C#
public class MyClass
{
	/// <remarks>Here is an example of a bulleted list:
	/// <list type="bullet">
	/// <item>
	/// <description>Item 1.</description>
	/// </item>
	/// <item>
	/// <description>Item 2.</description>
	/// </item>
	/// </list>
	/// </remarks>
	public static void Main() 
	{
		// …
	}
}
```
Tag: `<para>`
This tag is for use inside other tags, such as `<remarks>` or `<returns>`, and permits structure to be added to text.

Syntax:

`<para>content</para>`

content - The text of the paragraph. 

Example:
```C#
/// <summary>This is the entry point of the Point class 
/// testing program.
/// <para>This program tests each method and operator, 
/// and is intended to be run after any non-trivial 
/// maintenance has been performed on the Point 
/// class.
/// </para>
/// </summary>
public static void Main() 
{
	// …
}
```
Tag: `<param>`
This tag is used to describe a parameter for a method, constructor, or indexer.

Syntax:

`<param name="name">description</param>`

name - The name of the parameter.
description - A description of the parameter. 

Example:
```C#
/// <summary>This method changes the point's location to
/// the given coordinates.
/// </summary>
/// <param><c>xOr</c> is the new x-coordinate.</param>
/// <param><c>yOr</c> is the new y-coordinate.</param>
public void Move( int xOr, int yOr ) 
{
	X = xOr;
	Y = yOr;
}
```

Tag: `<paramref>`
This tag is used to indicate that a word is a parameter. The documentation file can be processed to format this parameter in some distinct way.

Syntax:

`<paramref name="name"/>`

name - The name of the parameter.

Example:
```C#
/// <summary>This constructor initializes the new Point to
///	(<paramref name="xOr"/>, <paramref name="yOr"/>).
/// </summary>
/// <param><c>xOr</c> is the new Point's x-coordinate.</param>
/// <param><c>yOr</c> is the new Point's y-coordinate.</param>
public Point( int xOr, int yOr ) 
{
	X = xOr;
	Y = yOr;
}
```

Tag: `<permission>`
This tag allows the security accessibility of a member to be documented. 

Syntax:

`<permission cref="member">description</permission>`
 
cref="member" - The name of a member. The documentation generator checks that the given code element exists and translates member to the canonical element name in the documentation file.
description - A description of the access to the member. 


Example:
```C#
/// <permission cref="System.Security.PermissionSet">Everyone can
/// access this method.</permission>
public static void Test() 
{
	// …
}
```

Tag: `<remarks>`
This tag is used to specify overview information about a type. (Use `<summary>` to describe the members of a type.)

Syntax:

`<remarks>description</remarks>`

description - The text of the remarks. 

Example:
```C#
/// <remarks>Class <c>Point</c> models a point in a two-dimensional 
/// plane.</remarks>
public class Point 
{
	// …
}

```
Tag: `<returns>`
This tag is used to describe the return value of a method.

Syntax:

`<returns>description</returns>`

description -  A description of the return value. 

Example:
```C#
/// <summary>Report a point's location as a string.</summary>
/// <returns>A string representing a point's location, in the form 
/// (x,y), without any leading, training, or embedded 
/// whitespace.
/// </returns>
public override string ToString() 
{
	return "(" + X + "," + Y + ")";
}

```
Tag: `<see>`
This tag allows a link to be specified within text. (Use `<seealso>` to indicate text that is to appear in a See Also section.)

Syntax:

`<see cref="member"/>`

cref="member" - The name of a member. The documentation generator checks that the given code element exists and passes member to the element name in the documentation file.

Example:
```C#
/// <summary>This method changes the point's location to
/// the given coordinates.
/// </summary>
/// <see cref="Translate"/>
public void Move( int xOr, int yOr ) 
{
	X = xOr;
	Y = yOr;
}
/// <summary>This method changes the point's location by
/// the given x- and y-offsets.
/// </summary>
/// <see cref="Move"/>
public void Translate( int xOr, int yOr ) 
{
	X += xOr;
	Y += yOr;
}
```

Tag: `<seealso>`
This tag allows an entry to be generated for the See Also section. (Use `<see>` to specify a link from within text.)

Syntax:

`<seealso cref="member"/>`

cref="member" - The name of a member. The documentation generator checks that the given code element exists and passes member to the element name in the documentation file.

Example:
```C#
/// <summary>This method determines whether two Points have the 
/// same location.
/// </summary>
/// <seealso cref="operator=="/>
/// <seealso cref="operator!="/>
public override bool Equals( object o ) 
{
	// …
}
```

Tag: `<summary>`
This tag can be used to describe a member for a type. (Use `<remarks>` to describe the type itself.)

Syntax:

`<summary>description</summary>`

description - A summary of the member. 

Example:
```C#
/// <summary>This constructor initializes the new Point to 
/// ( 0, 0 ).
/// </summary>
public Point() : this( 0, 0 ) 
{
}
```

Tag: `<value>`
This tag allows a property to be described.

Syntax:

`<value>property description</value>`

property description - A description for the property. 

Example:
```C#
/// <value>Property <c>X</c> represents the point's x-coordinate.</value>
public int X
{
	get { return x; }
	set { x = value; }
}
```

Tag: `<include>`
This tag is used to reference external files. The file attribute is the name of the file using relative or fully qualified paths. The include file itself in an XML document that holds XML Comments. The path attribute is an XPath statement that points to the parent element of the XML comments in the external document.

Example:
```C#
/// <include file=’MyXMLCommentFile.xml’
/// path=’doc/members/member[@name=”T:MyExampleClass”]/*’/>
public class MyExampleClass
{

	/// <include file=’MyXMLCommentFile.xml’
	/// path=’doc/members/member[@name=”M:MyExampleMethod”]/*’/>
	public string MyExampleMethod( string returnThis )
	{
		return returnThis;
	}

}
```
